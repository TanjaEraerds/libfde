#ifndef __FORTRES_EXCEPTION_FMOD
#define __FORTRES_EXCEPTION_FMOD

#include "fortres/itfUtil.fpp"
#include "fortres/exception.fpp"
#include "fortres/exception_types.xpp"

#include "fortres/stringref.fmod"

      module exception
        use stringref
        use iso_c_binding
        implicit none

#       define _fortres_exception_type(_ident, _num) \
          integer*4, parameter :: _ident = _same(x)_str(_num);
          _fortres_ExceptionTable
#       undef  _fortres_exception_type
      
        ! Using the try-catch mechanism requires an interface definition
        !   matching the subroutine to call via try.
        ! The following defines the default interface for trying any
        !   subroutine without arguments.
        ! For trying any other subroutine it's signature has to be defined
        !   manually.
        ! The preprocessor macros _tryProcedure and _end_tryProcedure
        !   help to define them correctly.
        ! Keep in mind that such interface is used to call a C-function.
        ! For this reason it is important to use the type kinds provided by
        !   fortran's iso_c_binding module for specifying the argument types.
        ! As there's no standard for passing fortran strings to C the module stringref
        !   defines a wrapper type StringRef_t that can handle strings portably.
        !
        ! Definding the interface for a subroutine taking three arguments,
        !   e.g. an integer, a real, and a string, might look like this:
        !
        ! interface try
        !   _tryProcedure( some_unique_name_, _args_3 ) !<< number of expected arguments
        !     integer(kind=c_int) :: arg1   !<< define arguments by dummy names arg#
        !     real(kind=c_double) :: arg2   !<< ... starting at arg1, up to arg20
        !     type(StringRef_t)   :: arg3
        !   _end_tryProcedure
        ! end interface
        !
      
        interface try
          _tryProcedure( exception_try_0_args_, _args_0 )
          _end_tryProcedure
        end interface
      
        interface
          subroutine push_cleanup( proc ) _cID(f_push_cleanup)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: proc
          end subroutine

          subroutine pop_cleanup( exec ) _cID(f_pop_cleanup)
            use, intrinsic :: iso_c_binding
            integer(kind=c_int), value :: exec
          end subroutine

          subroutine set_synchronizer( sync ) _cID(f_set_synchronizer)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: sync
          end subroutine

          subroutine get_context( context, id ) _cID(f_get_context)
            use, intrinsic :: iso_c_binding
            type (c_ptr),  intent(inout) :: context
            integer*4, value, intent(in) :: id
          end subroutine

          subroutine set_traceproc( tracer ) _cID(f_set_traceproc)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: tracer
          end subroutine
        end interface

        contains

!_PROC_EXPORT(proc)
        function proc( sub ) result(res)
          procedure()     :: sub
          type (c_funptr) :: res
          res = c_funloc( sub )
        end function

!_PROC_EXPORT(throw)
        subroutine throw( code, what )
          ! explicit procedure forces compiler to keep what-string alive!
          implicit none
          integer,          intent(in) :: code
          character(len=*), intent(in) :: what

          interface
            subroutine f_throw( code, what ) _cID(f_throw)
              use, intrinsic :: iso_c_binding
              import StringRef_t
              integer(kind=c_int), value :: code
              type (StringRef_t)         :: what
            end subroutine
          end interface

          call f_throw( code, str(trim(what)) )
        end subroutine
      end module

#endif

