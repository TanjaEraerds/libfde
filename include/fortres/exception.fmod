#ifndef __FORTRES_EXCEPTION_FMOD
#define __FORTRES_EXCEPTION_FMOD

#if !defined _MODULENAME_exception
# define _MODULENAME_exception  exception
#endif

#include "fortres/itfUtil.fpp"
#include "fortres/exception.fpp"
#include "fortres/exception_types.xpp"

#include "fortres/stringref.fmod"

      module _MODULENAME_exception
        use _MODULENAME_stringref
        use iso_c_binding
        implicit none
        private

#       define _fortres_exception_type(_ident, _num) \
          integer*4, public, parameter :: _ident = _same(x)_str(_num);
          _fortres_ExceptionTable
#       undef  _fortres_exception_type
      
        ! Using the try-catch mechanism requires an interface definition
        !   matching the subroutine to call via try.
        ! The following defines the default interface for trying any
        !   subroutine without arguments.
        ! For trying any other subroutine it's signature has to be defined
        !   manually.
        ! The preprocessor macros _tryProcedure and _end_tryProcedure
        !   help to define them correctly.
        ! Keep in mind that such interface is used to call a C-function.
        ! For this reason it is important to use the type kinds provided by
        !   fortran's iso_c_binding module for specifying the argument types.
        ! As there's no standard for passing fortran strings to C the module stringref
        !   defines a wrapper type StringRef_t that can handle strings portably.
        !
        ! Definding the interface for a subroutine taking three arguments,
        !   e.g. an integer, a real, and a string, might look like this:
        !
        ! interface try
        !   _tryProcedure( some_unique_name_, _args_3 ) !<< number of expected arguments
        !     integer(kind=c_int) :: arg1   !<< define arguments by dummy names arg#
        !     real(kind=c_double) :: arg2   !<< ... starting at arg1, up to arg20
        !     type(StringRef_t)   :: arg3
        !   _end_tryProcedure
        ! end interface
        !
      
        interface try
          _tryProcedure( exception_try_0_args_, _args_0 )
          _end_tryProcedure
        end interface
      
        interface
          subroutine push_cleanup( proc ) _cID(f_push_cleanup)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: proc
          end subroutine

          subroutine pop_cleanup( exec ) _cID(f_pop_cleanup)
            use, intrinsic :: iso_c_binding
            integer(kind=c_int), value :: exec
          end subroutine

          subroutine set_synchronizer( sync ) _cID(f_set_synchronizer)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: sync
          end subroutine

          subroutine get_context( context, id ) _cID(f_get_context)
            use, intrinsic :: iso_c_binding
            type (c_ptr),  intent(inout) :: context
            integer*4, value, intent(in) :: id
          end subroutine

          subroutine set_traceproc( tracer ) _cID(f_set_traceproc)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: tracer
          end subroutine
        end interface

        public :: try, throw, proc, c_null_ptr
        public :: push_cleanup, pop_cleanup, set_traceproc
        public :: set_synchronizer, get_context
        public :: setup_standardExceptions

        public :: StringRef_t, str, strBuf, len

      !-------------------
        contains
      !-------------------

!_PROC_EXPORT(proc)
        function proc( sub ) result(res)
          procedure()     :: sub
          type (c_funptr) :: res
          res = c_funloc( sub )
        end function

!_PROC_EXPORT(throw)
        subroutine throw( code, what )
          ! explicit procedure forces compiler to keep what-string alive!
          implicit none
          integer,          intent(in) :: code
          character(len=*), intent(in) :: what

          interface
            subroutine f_throw( code, what ) _cID(f_throw)
              use, intrinsic :: iso_c_binding
              import StringRef_t
              integer(kind=c_int), value :: code
              type (StringRef_t)         :: what
            end subroutine
          end interface

          call f_throw( code, str(what) )
        end subroutine


!_PROC_EXPORT(setup_standardExceptions)
        subroutine setup_standardExceptions()
          _use_if_INTEL(ifport)
          integer :: code

# if defined __INTEL_COMPILER
#         define _signal     signalqq
#         define _SIGABRT    SIG$ABORT
#         define _SIGTERM    SIG$TERM
#         define _SIGILL     SIG$ILL
#         define _SIGSEGV    SIG$SEGV
#         define _SIGINT     SIG$INT
#         define _SIGFPE     SIG$FPE

# else
#         define _signal     signal
#         define _SIGABRT     6
#         define _SIGTERM    15
#         define _SIGILL      4
#         define _SIGSEGV    11
#         define _SIGINT      2
#         define _SIGFPE      8
# endif
          code = _signal( _SIGABRT, handle_abort )
          code = _signal( _SIGTERM, handle_term )
          code = _signal( _SIGILL,  handle_ill )
          code = _signal( _SIGSEGV, handle_segv )
          code = _signal( _SIGINT,  handle_int )
          code = _signal( _SIGFPE,  handle_fpe )
        end subroutine

        integer*4 function handle_abort( signum )
          integer*2 :: signum
          handle_abort = 1
          call throw( AbortExecution, 'handle_abort' )
        end function
      
        integer*4 function handle_term( signum )
          integer*2 :: signum
          handle_term = 1
          call throw( TerminateExecution, 'handle_term' )
        end function
      
        integer*4 function handle_ill( signum )
          integer*2 :: signum
          handle_ill = 1
          call throw( IllegalInstruction, 'handle_ill' )
        end function
      
        integer*4 function handle_segv( signum )
          integer*2 :: signum
          handle_segv = 1
          call throw( SegmentationFault, 'handle_segv' )
        end function
      
        integer*4 function handle_int( signum )
          integer*2 :: signum
          handle_int = 1
          call throw( KeyboardInterrupt, 'handle_int' )
        end function
      
        integer*4 function handle_fpe( signum )
          integer*2 :: signum
          handle_fpe = 1
          call throw( FloatingPointError, 'handle_fpe' )
        end function
      end module

#endif

