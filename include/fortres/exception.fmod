#ifndef __FORTRES_EXCEPTION_FMOD
#define __FORTRES_EXCEPTION_FMOD

#if !defined _MODULENAME_try_interface
# define _MODULENAME_exception  try_interface
#endif

#if !defined _MODULENAME_exception
# define _MODULENAME_exception  exception
#endif

#include "fortres/itfUtil.fpp"
#include "fortres/exception.fpp"
#include "fortres/exception_types.xpp"

#include "fortres/stringref.fmod"
#include "fortres/tracestack.fmod"

      ! Generic wrapper routine around C-Funktion f_try
      ! This routine is a bit tricky, since Fortran still does NOT
      !   * support variable argument lists
      !   * control ByRef/ByVal-argument passing per call
      !   * allow easy void-pointer handling
      !
      subroutine try__( res, catch, what, tgt, _enum_20(arg) )
        use, intrinsic :: iso_c_binding
        use _MODULENAME_stringref
        integer(kind=c_int) :: res
        integer             :: catch(*)
        type(StringRef_t)   :: what
        type(c_funptr)      :: tgt
        type(c_ptr)         :: _enum_20(arg)

        interface
          function c_try_( catch, what, tgt, _enum_20(arg), x_ ) _cID(f_try)
            use, intrinsic :: iso_c_binding
            use _MODULENAME_stringref
            integer(kind=c_int),   intent(in) :: catch(*)
            type(StringRef_t)                 :: what
            type(c_funptr), value, intent(in) :: tgt
            type(c_ptr),    value, intent(in) :: _enum_20(arg), x_
            integer(kind=c_int)               :: c_try_
          end function
        end interface

        res = c_try_( catch, what, tgt, _enum_20(arg), _list_1(_noArg) )
      end subroutine


      module _MODULENAME_try_interface
        use _MODULENAME_stringref
        use iso_c_binding
        
        ! Using the try-catch mechanism requires an interface definition
        !   matching the subroutine that should be called by try.
        ! The following default interfaces are supported for trying ...
        !   * any subroutine without arguments
        !   * any subroutine accepting one character string
        !   * any subroutine accepting a StringRef_t
        ! To support other subroutines the matching interfaces have to
        !   be provided by extending the try interface separately.
        ! Note that the number of arguments is currently limited to 20!

        interface try
          module procedure try_void, try_chs, try_str
        end interface

        contains

!_PROC_EXPORT(try_void)
        function try_void( catch, what, tgt ) result(res)
!                    . o O (define this to keep the 72 column limit!)
#         define _tryBaseArgs   res, catch, strBuf(what), c_funloc(tgt)

          integer          :: catch(*)
          character(len=*) :: what
          procedure()      :: tgt
          integer          :: res
          call try__( _tryBaseArgs, _list_20(_noArg) )
        end function

!_PROC_EXPORT(try_chs)
        function try_chs( catch, what, tgt, arg1 ) result(res)
          integer                   :: catch(*)
          character(len=*)          :: what
          procedure()               :: tgt
          character(len=*)          :: arg1
          integer                   :: res
          type(StringRef_t), target :: argStr
          argStr = str(arg1)
          call try__( _tryBaseArgs, c_loc(argStr), _list_19(_noArg) )
        end function

!_PROC_EXPORT(try_str)
        function try_str( catch, what, tgt, _enum_1(arg) ) result(res)
          integer                   :: catch(*)
          character(len=*)          :: what
          procedure()               :: tgt
          type(StringRef_t), target :: _enum_1(arg)
          integer                   :: res
          call try__( _tryBaseArgs, _mapEnum_1(c_loc,arg), _list_19(_noArg) )
        end function
      end module


      module _MODULENAME_exception
        use _MODULENAME_stringref
        use _MODULENAME_tracestack
        use _MODULENAME_try_interface
        implicit none
        private

#       define _fortres_exception_type(_ident, _num) \
          integer*4, public, parameter :: _ident = _same(x)_str(_num);
          _fortres_ExceptionTable
#       undef  _fortres_exception_type
      
        interface
          subroutine throw_( code, what ) _cID(f_throw)
            use, intrinsic :: iso_c_binding
            import StringRef_t
            integer(kind=c_int), value :: code
            type (StringRef_t)         :: what
          end subroutine

          subroutine push_cleanup_( proc ) _cID(f_push_cleanup)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: proc
          end subroutine

          subroutine pop_cleanup_( exec ) _cID(f_pop_cleanup)
            use, intrinsic :: iso_c_binding
            integer(kind=c_int), value :: exec
          end subroutine

          subroutine set_synchronizer_( sync ) _cID(f_set_synchronizer)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: sync
          end subroutine

          subroutine get_context_( context, id ) _cID(f_get_context)
            use, intrinsic :: iso_c_binding
            type (c_ptr),  intent(inout) :: context
            integer*4, value, intent(in) :: id
          end subroutine

          subroutine set_traceproc_( tracer ) _cID(f_set_traceproc)
            use, intrinsic :: iso_c_binding
            type (c_funptr), value, intent(in) :: tracer
          end subroutine
        end interface

        public :: try, throw, proc, c_null_ptr
        public :: push_cleanup, pop_cleanup, set_traceproc
        public :: set_synchronizer, get_context
        public :: setup_standardExceptions

        public :: StringRef_t, str, strBuf, len

      !-------------------
        contains
      !-------------------

!_PROC_EXPORT(proc)
        function proc( sub ) result(res)
          procedure()     :: sub
          type (c_funptr) :: res
          res = c_funloc( sub )
        end function

!_PROC_EXPORT(throw)
        subroutine throw( code, what )
          implicit none
          integer,          intent(in) :: code
          character(len=*), intent(in) :: what
          call throw_( code, str(what) )
        end subroutine

!_PROC_EXPORT(push_cleanup)
        subroutine push_cleanup( proc )
          procedure() :: proc
          call push_cleanup_( c_funloc(proc) )
        end subroutine

!_PROC_EXPORT(pop_cleanup)
        subroutine pop_cleanup( callHandler )
          logical, optional :: callHandler
          logical           :: callHandler_ = .true.
          if (present(callHandler)) callHandler_ = callHandler
          call pop_cleanup_( merge(1,0,callHandler_) )
        end subroutine

!_PROC_EXPORT(set_synchronizer)
        subroutine set_synchronizer( sync )
          procedure() :: sync
          call set_synchronizer_( c_funloc( sync ) )
        end subroutine

!_PROC_EXPORT(get_context)
        subroutine get_context( context, id )
          type (c_ptr), intent(inout) :: context
          integer*4,    intent(in)    :: id
          call get_context_( context, id )
        end subroutine

!_PROC_EXPORT(set_traceproc)
        subroutine set_traceproc( tracer )
          procedure() :: tracer
          call set_traceproc_( c_funloc(tracer) )
        end subroutine


!_PROC_EXPORT(setup_standardExceptions)
        subroutine setup_standardExceptions()
          _use_if_INTEL(ifport)
          integer :: code

# if defined __INTEL_COMPILER
#         define _signal     signalqq
#         define _SIGABRT    SIG$ABORT
#         define _SIGTERM    SIG$TERM
#         define _SIGILL     SIG$ILL
#         define _SIGSEGV    SIG$SEGV
#         define _SIGINT     SIG$INT
#         define _SIGFPE     SIG$FPE

# else
#         define _signal     signal
#         define _SIGABRT     6
#         define _SIGTERM    15
#         define _SIGILL      4
#         define _SIGSEGV    11
#         define _SIGINT      2
#         define _SIGFPE      8
# endif
          code = _signal( _SIGABRT, handle_abort )
          code = _signal( _SIGTERM, handle_term )
          code = _signal( _SIGILL,  handle_ill )
          code = _signal( _SIGSEGV, handle_segv )
          code = _signal( _SIGINT,  handle_int )
          code = _signal( _SIGFPE,  handle_fpe )
        end subroutine

        integer*4 function handle_abort( signum )
          integer*2 :: signum
          handle_abort = 1
          call throw( AbortExecution, 'handle_abort' )
        end function
      
        integer*4 function handle_term( signum )
          integer*2 :: signum
          handle_term = 1
          call throw( TerminateExecution, 'handle_term' )
        end function
      
        integer*4 function handle_ill( signum )
          integer*2 :: signum
          handle_ill = 1
          call throw( IllegalInstruction, 'handle_ill' )
        end function
      
        integer*4 function handle_segv( signum )
          integer*2 :: signum
          handle_segv = 1
          call throw( SegmentationFault, 'handle_segv' )
        end function
      
        integer*4 function handle_int( signum )
          integer*2 :: signum
          handle_int = 1
          call throw( KeyboardInterrupt, 'handle_int' )
        end function
      
        integer*4 function handle_fpe( signum )
          integer*2 :: signum
          handle_fpe = 1
          call throw( FloatingPointError, 'handle_fpe' )
        end function
      end module

#endif

