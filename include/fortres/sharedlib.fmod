#ifndef __FORTRES_SHAREDLIB_FMOD
#define __FORTRES_SHAREDLIB_FMOD

#include "fortres/itfUtil.fpp"

      module sharedlib
        use stringref
        use, intrinsic :: iso_c_binding
        implicit none
        private

        public :: plugin_set_path, plugin_register, plugin_iterate
        public :: plugin_filePath_to_id
        public :: plugin_sym, plugin_proc, plugin_call
        public :: plugin_try_sym, plugin_try_proc, plugin_try_call
        public :: plugin_call_exc

        interface
          subroutine PluginInfoHandler( id, fp )
            import StringRef_t
            type(StringRef_t) :: id, fp
          end subroutine
      
          subroutine plugin_set_path_( p, l, c ) _cID(f_plugin_set_path)
            import StringRef_t
            type(StringRef_t), intent(in) :: p !< plugin path
            type(StringRef_t), intent(in) :: l !< library path
            type(StringRef_t), intent(in) :: c !< check symbol
          end subroutine

          subroutine plugin_register_( id ) _cID(f_plugin_register)
            import StringRef_t
            type(StringRef_t), intent(in) :: id
          end subroutine

          subroutine plugin_iterate_( op ) _cID(f_plugin_iterate)
            import c_funptr
            type(c_funptr), value, intent(in) :: op
          end subroutine

          subroutine plugin_p2i_( fp, id ) _cID(f_plugin_filePath_to_id)
            import StringRef_t
            type(StringRef_t), intent(in) :: fp !< plugin filePath
            type(StringRef_t)             :: id !< plugin id
          end subroutine

          ! routines throwing exceptions ...

          function plugin_sym_( pId, sId ) _cID(f_plugin_sym)
            import StringRef_t, c_ptr
            type(StringRef_t), intent(in) :: pId !< pluginId
            type(StringRef_t), intent(in) :: sId !< symbolId
            type(c_ptr)                   :: plugin_sym_
          end function

          function plugin_proc_( pId, sId ) _cID(f_plugin_sym)
            import StringRef_t, c_funptr
            type(StringRef_t), intent(in) :: pId !< pluginId
            type(StringRef_t), intent(in) :: sId !< symbolId
            type(c_funptr)                :: plugin_proc_
          end function

          subroutine plugin_call_exc( pId, sId ) _cID(f_plugin_call)
            import StringRef_t
            type(StringRef_t), intent(in) :: pId !< pluginId
            type(StringRef_t), intent(in) :: sId !< symbolId
          end subroutine

          ! routines returning NULL pointers ...

          function plugin_try_sym_( pId, sId ) _cID(f_plugin_try_sym)
            import StringRef_t, c_ptr
            type(StringRef_t), intent(in) :: pId !< pluginId
            type(StringRef_t), intent(in) :: sId !< symbolId
            type(c_ptr)                   :: plugin_try_sym_
          end function

          function plugin_try_proc_( pId, sId ) _cID(f_plugin_try_sym)
            import StringRef_t, c_funptr
            type(StringRef_t), intent(in) :: pId !< pluginId
            type(StringRef_t), intent(in) :: sId !< symbolId
            type(c_funptr)                :: plugin_try_proc_
          end function

          function plugin_try_call_( pId, sId ) _cID(f_plugin_try_call)
            import StringRef_t, c_int
            type(StringRef_t), intent(in) :: pId !< pluginId
            type(StringRef_t), intent(in) :: sId !< symbolId
            integer(kind=c_int)           :: plugin_try_call_
          end function
        end interface

      contains

          subroutine plugin_set_path( path, lPath, chkSym )
            character(len=*)           :: path
            character(len=*), optional :: lPath,  chkSym
            type(StringRef_t)          :: lPath_, chkSym_
            if (present(lPath))  lPath_  = str(lPath)
            if (present(chkSym)) chkSym_ = str(chkSym)
            call plugin_set_path_( str(path), lPath_, chkSym_ )
          end subroutine

          subroutine plugin_register( pluginFilePath )
            character(len=*) :: pluginFilePath
            call plugin_register_( str(pluginFilePath) )
          end subroutine

          subroutine plugin_iterate( op )
            procedure(PluginInfoHandler) :: op
            call plugin_iterate_( c_funloc(op) )
          end subroutine

          subroutine plugin_filePath_to_id( filePath, id )
            character(len=*), intent(in)  :: filePath
            character(len=*)              :: id
            call plugin_p2i_( str(filePath), str(id, .false.) )
          end subroutine

          ! accessing plugin procedures and symbols by pointer
          !  plugin_## routines throw exceptions on error!
          !  So it's save using a returned pointer immediately.

          function plugin_sym( pluginId, symId ) result(res)
            character(len=*) :: pluginId, symId
            type(c_ptr)      :: res
            res = plugin_sym_( str(pluginId), str(symId) )
          end function

          function plugin_proc( pluginId, symId ) result(res)
            character(len=*) :: pluginId, symId
            type(c_funptr)   :: res
            res = plugin_proc_( str(pluginId), str(symId) )
          end function

          subroutine plugin_call( pluginId, symId )
            character(len=*) :: pluginId, symId
            call plugin_call_exc( str(pluginId), str(symId) )
          end subroutine

          ! accessing plugin procedures and symbols by pointer
          !  plugin_try_## routines return NULL pointer on error!

          function plugin_try_sym( pluginId, symId ) result(res)
            character(len=*) :: pluginId, symId
            type(c_ptr)      :: res
            res = plugin_try_sym_( str(pluginId), str(symId) )
          end function

          function plugin_try_proc( pluginId, symId ) result(res)
            character(len=*) :: pluginId, symId
            type(c_funptr)   :: res
            res = plugin_try_proc_( str(pluginId), str(symId) )
          end function

          function plugin_try_call( pluginId, symId ) result(res)
            character(len=*) :: pluginId, symId
            logical          :: res
            res = (plugin_try_call_( str(pluginId), str(symId) ) /= 0)
          end function

      end module

#endif

